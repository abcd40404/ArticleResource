---
title: Codeforces Round 402 (Div. 2)
date: 2017-02-28 23:27:35
tags:
categories: [解題區, Codeforces]
---
目錄
===

## A. Pupils Redistribution
[題目](http://codeforces.com/contest/779/problem/A)

## input
每組 n 人： 1 <= n <= 100
學業值 a: 1 <= a <= 5

## 題解
每個人的學業表現值為1~5
在學校裡分為 A,B 兩組, 每組有 n 人
今要使兩組在各表現值的人數相同
兩組的人員可以交換, 求最少要交換幾次？

## 作法
要使兩組人數相同, 就代表一組在該值的人數為 2 / n
算出總交換次數, 再除以 2 為答案

## AC code
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef pair <int,int> pii;
typedef long long ll;

#define pb push_back
#define sz(a) (int)a.size()
#define INF 0x3f3f3f3f
#define st first
#define nd second
#define DEBUG(x) printf("Here: %d\n", x), exit(0);
// LLONG_MIN LLONG_MAX INT_MIN INT_MAX

int a[50], b[50], p[50];

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    for(int i = 0; i < n; i++){
        int x;
        cin >> x;
        a[x]++;
    }
    for(int i = 0; i < n; i++){
        int x;
        cin >> x;
        b[x]++;
    }
    int ans = 0;
    for(int i = 1; i <= 5 ;i++){
        if(a[i] == 0 && b[i] == 0)
            continue;
        if((a[i] + b[i]) % 2 != 0){
            printf("-1\n");
            return 0;
        }
        else{
            ans += abs((a[i] + b[i]) / 2 - a[i]);
        }

    }
    printf("%d\n", ans / 2);
    return 0;
}
```

## B. Weird Rounding
[題目](http://codeforces.com/contest/779/problem/B)

## input
數字n: 0 ≤ n ≤ 2 000 000 000
數字k: 1 ≤ k ≤ 9

## 題解
給一個數字 n, 可以刪除任意一個 digit
求最少要刪幾個, 使結果可以被 10^k 整除
ps: 0 可以被任意數整除, 且不允許 00 這種情況出現

## 作法
因為要被 10 的次方整除, 那就從最低位數開始計算
直到找到足夠的 0 被除, 刪掉的位數即是答案

## AC code
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef pair <int,int> pii;
typedef long long ll;

#define pb push_back
#define sz(a) (int)a.size()
#define INF 0x3f3f3f3f
#define st first
#define nd second
#define DEBUG(x) printf("Here: %d\n", x), exit(0);
// LLONG_MIN LLONG_MAX INT_MIN INT_MAX


int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    int k;
    cin >> s >> k;
    int len = k;
    int num = 0;
    int ans = 0;
    for(int i = s.length() - 1; i >= 0; i--){
        if(s[i] == '0')
            num++;
        else
            ans++;
        if(num == len)
            break;
    }
    if(num != len)
        ans = INF;
    ans = min(ans, sz(s) - 1);
    cout << ans << endl;
    return 0;
}
```

## C. Dishonest Sellers
[題目](http://codeforces.com/contest/779/problem/C)

## input
n個物品要買： 1 ≤ n ≤ 2·10^5
k個需要現在馬上買： 0 ≤ k ≤ n
物品價格： 1 ≤ a ≤ 10^4

## 題解
現有 n 個物品價格為 a, 一個禮拜之後會變成 b
Igor 需要現在就買最少 k 個物品, 而他總共要買 n 個
求他最少需要多少錢買完全部物品

## 作法
由於價格有可能上升或下降
所以先把每個物品的價格變化值存起來
再根據這個去排序
價格變化增加最多的, 就現在買（可以買不只 k 個）
減少最多的(負值)就之後再買


## AC code
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef pair <int,int> pii;
typedef long long ll;

#define pb push_back
#define sz(a) (int)a.size()
#define INF 0x3f3f3f3f
#define st first
#define nd second
#define DEBUG(x) printf("Here: %d\n", x), exit(0);
// LLONG_MIN LLONG_MAX INT_MIN INT_MAX

struct N{
    int dis;
    int idx;
}data[202020];
int a[202020], b[202020];

bool cmp(N aa, N bb){
    return aa.dis < bb.dis;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    int n, k;
    cin >> n >> k;
    for(int i = 0; i < n; i++){
        cin >> a[i];
    }
    for(int i = 0; i < n; i++)
        cin >> b[i];
    for(int i = 0; i < n; i++){
        data[i].dis = a[i] - b[i];
        data[i].idx = i;
    }
    sort(data, data + n, cmp);
    int cnt = 0;
    ll ans = 0;
    for(int i = 0; i < n; i++){
        if(cnt != k){
            ans += a[data[i].idx];
            cnt++;
        }
        else{
            if(data[i].dis <= 0)
                ans += a[data[i].idx];
            else
                ans += b[data[i].idx];
        }
    }
    cout << ans << endl;
    return 0;
}
```

## D. String Game
[題目](http://codeforces.com/contest/779/problem/D)

## input

## 題解

## 作法

## AC code
```cpp
```
